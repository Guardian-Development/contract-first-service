import java.text.SimpleDateFormat

plugins {
	id 'org.springframework.boot' version "$springFrameworkVersion"
	id 'io.spring.dependency-management' version "$springDependencyManagementVersion"
	id 'org.openapi.generator' version "$openApiGeneratorVersion"
	id 'jacoco'
	id 'java'
	id 'maven-publish'
}

group = "$serviceGroupId"
version = "$serviceVersion"
sourceCompatibility = '14'

java {
	withSourcesJar()
}

repositories {
	mavenCentral()
}

sourceSets {
	// adds an component test source set
	componentTest {
		java.srcDir "$projectDir/src/componentTest/java"
		resources.srcDir "$projectDir/src/componentTest/resources"
		compileClasspath += main.output + test.output
		runtimeClasspath += main.output + test.output
	}
}

// makes component test source set extend the test sources
// downloadDependenciesConfig just provides a target to pull in dependencies only, useful when doing docker caching
// downloadJacoco can be used to pull the jacoco runtime jar needed for code coverage in component tests
configurations {
	downloadDependenciesConfig.extendsFrom implementation, testImplementation, testRuntime
	componentTestImplementation.extendsFrom testImplementation
	componentTestRuntime.extendsFrom testRuntime
	downloadJacoco
}

dependencies {
	// spring dependencies
	implementation "org.springframework.boot:spring-boot-starter-webflux"
	implementation "org.springframework.boot:spring-boot-starter-actuator"
	implementation "org.springframework.boot:spring-boot-starter-validation"

	// open-api dependencies
	implementation "io.swagger.parser.v3:swagger-parser:$swaggerParserVersion"
	implementation "org.openapitools:jackson-databind-nullable:$jacksonDataBindVersion"

	// test dependencies
	testImplementation "org.junit.jupiter:junit-jupiter-api:$junitVersion"
	testRuntime "org.junit.jupiter:junit-jupiter-engine:$junitVersion"

	// code coverage dependencies
	downloadJacoco "org.jacoco:org.jacoco.agent:$jacocoToolVersion:runtime"
}

// adds build info to build/resources/main/META-INF for actuator endpoint
springBoot {
	buildInfo()
}

// generates the spring controller interfaces from openapi spec in src/main/resources/service.yaml
openApiGenerate {
	generatorName = "spring"
	inputSpec = "$projectDir/src/main/resources/service.yaml"
	outputDir = "$buildDir/generated"
	apiPackage = "org.guardiandev.helloservice.api"
	invokerPackage = "org.guardiandev.helloservice"
	modelPackage = "org.guardiandev.helloservice.models"
	configOptions = [
		dateLibrary: "java8",
		interfaceOnly: "true",
		reactive: "true",
	]
}

// forces generation of spring controllers on compile, adding them to the sources for compilation
compileJava.dependsOn tasks.openApiGenerate
sourceSets.main.java.srcDir "$buildDir/generated/src/main/java"
sourceSets.main.resources.srcDir "$buildDir/generated/src/main/resources"

// pull dependencies needed by the application
task downloadDependencies (type: Exec) {
	configurations.downloadDependenciesConfig.files
	commandLine 'echo', 'Downloaded all dependencies'
}

// run the componentTest/** tests
task componentTest(type: Test) {
	description = 'Runs component tests'
	group = 'verification'
	testClassesDirs = sourceSets.componentTest.output.classesDirs
	classpath = sourceSets.componentTest.runtimeClasspath
	outputs.upToDateWhen { false }
}

// builds the docker image, tagging it with the same group id, name, and version as the JAR
task buildDockerimage(type: Exec) {
	workingDir "$projectDir"
	commandLine 'docker', 'build', '.', '-t', "$serviceGroupId/$serviceApplicationName:$serviceVersion"
}

// turns on the docker compose environment including the service and dependencies
task composeUp(type: Exec) {
	dependsOn buildDockerimage
	workingDir "$projectDir"
	environment << [ SERVICE_TAG: "$serviceVersion", SERVICE_GROUP: "$serviceGroupId", SERVICE_NAME: "$serviceApplicationName", SPRING_PROFILE: "docker" ]
	commandLine 'docker-compose', 'up', '-d'
}

// copies the jacoco agent to the build dir, stripping out any version numbers
// this means we can reliable mount the agent from within a docker container
task copyJacocoAgent(type: Copy) {
	from configurations.downloadJacoco
	into "$buildDir/jacoco"

	// strip version number out of agent jar
	configurations.downloadJacoco.allDependencies.each {
		rename "-${it.version}", ""
	}
}

// docker compose up the jacoco override environment, which mounts the jacoco agent and connects it to the app JVM
task composeUpJacoco(type: Exec) {
	dependsOn buildDockerimage, copyJacocoAgent
	workingDir "$projectDir"
	environment << [ SERVICE_TAG: "$serviceVersion", SERVICE_GROUP: "$serviceGroupId", SERVICE_NAME: "$serviceApplicationName", SPRING_PROFILE: "docker" ]
	commandLine 'docker-compose', '-f', 'docker-compose.jacoco.override.yml', 'up', '-d'
}

// turns on only the services registered in the docker-compose file (not override files)
task composeDependenciesUp(type: Exec) {
	workingDir "$projectDir"
	commandLine 'docker-compose', '-f', 'docker-compose.yml', 'up', '-d'
}

// task that simply waits for the service health endpoint to return 200
task waitForService {
	doLast {
		def responseCode = null

		while(responseCode != 200) {
			sleep 1000
			try {
				def req = "$serviceConnectionString".toURL().openConnection()
				responseCode = req.getResponseCode()
				logger.log(LogLevel.INFO, "Response returned from service $responseCode")
			}
			catch(Exception) {
				logger.log(LogLevel.INFO, "Failed to connect to service")
			}
		}
	}
}

// saves all docker compose logs to a file in the build directory named after the date and time
task saveDockerLogsToFile(type: Exec) {
	commandLine 'docker-compose', 'logs', '--no-color'
	doFirst {
		def date = new Date()
		def sdf = new SimpleDateFormat("MM-dd-yyyy-HH:mm:ss")
		def uniqueId = sdf.format(date)
		standardOutput new FileOutputStream("$buildDir/compose-$uniqueId-logs.txt")
	}
}

// turns off all docker compose resources
task composeDown(type: Exec) {
	workingDir "$projectDir"
	commandLine 'docker-compose', 'down', '-t', '60', '-v'
}

// print tests out to console as they run
def testLogging = {
	afterTest { desc, result ->
		logger.quiet "Test ${desc.name} [${desc.className}] with result: ${result.resultType}"
	}
}

test {
	configure testLogging
	useJUnitPlatform()
}

componentTest {
	configure testLogging
	useJUnitPlatform()
}

// runs component tests using docker compose to turn the service on, execute tests, then save logs to file
// and turn the service off
task componentTestDocker {
	dependsOn componentTestClasses, composeUp, waitForService
	doLast {
		componentTest.executeTests()
	}
	finalizedBy saveDockerLogsToFile, composeDown
}

// runs component tests using docker compose and the jacoco agent to record test coverage
task componentTestCoverageDocker {
	dependsOn componentTestClasses, composeUpJacoco, waitForService
	doLast {
		componentTest.executeTests()
	}
	finalizedBy saveDockerLogsToFile, composeDown
}

// adding jacoco test reporting
jacoco {
	toolVersion = "$jacocoToolVersion"
}

// creates a code coverage report including both unit and component tests
// excludes generates api controllers/models from openapi state
task fullCoverageReport(type: JacocoReport) {
	// run tests
	dependsOn test, componentTestCoverageDocker
	// include test exec coverage files
	executionData tasks.withType(Test)
	// create coverage for main source set files
	sourceSets sourceSets.main
	// generate reports to jacoco-reports
	reports {
		html.enabled = true
		html.destination file("$buildDir/jacoco-reports")
	}
	// do not include generated files in source set for coverage
	afterEvaluate {
		classDirectories.setFrom(files(classDirectories.files.collect {
			fileTree(dir: it, exclude: ['org/guardiandev/helloservice/api/**', 'org/guardiandev/helloservice/models/**'])
		}))
	}
}

// adding components and bootJar to the published artifacts
publishing {
	publications {
		bootJava(MavenPublication) {
			from components.java
			artifact bootJar
		}
	}
}